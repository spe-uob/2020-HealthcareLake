"use strict";
/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v4_1 = __importDefault(require("uuid/v4"));
const fhir_works_on_aws_interface_1 = require("fhir-works-on-aws-interface");
const dynamoDb_1 = require("./dynamoDb");
const dynamoDbBundleService_1 = require("./dynamoDbBundleService");
const dynamoDbUtil_1 = require("./dynamoDbUtil");
const dynamoDbParamBuilder_1 = __importDefault(require("./dynamoDbParamBuilder"));
const dynamoDbHelper_1 = __importDefault(require("./dynamoDbHelper"));
class DynamoDbDataService {
    constructor(dynamoDb) {
        this.updateCreateSupported = false;
        this.dynamoDbHelper = new dynamoDbHelper_1.default(dynamoDb);
        this.transactionService = new dynamoDbBundleService_1.DynamoDbBundleService(dynamoDb);
        this.dynamoDb = dynamoDb;
    }
    async readResource(request) {
        return this.dynamoDbHelper.getMostRecentValidResource(request.resourceType, request.id);
    }
    async vReadResource(request) {
        const { resourceType, id, vid } = request;
        const params = dynamoDbParamBuilder_1.default.buildGetItemParam(id, parseInt(vid, 10));
        const result = await this.dynamoDb.getItem(params).promise();
        if (result.Item === undefined) {
            throw new fhir_works_on_aws_interface_1.ResourceVersionNotFoundError(resourceType, id, vid);
        }
        let item = dynamoDb_1.DynamoDBConverter.unmarshall(result.Item);
        item = dynamoDbUtil_1.DynamoDbUtil.cleanItem(item);
        return {
            message: 'Resource found',
            resource: item,
        };
    }
    async createResource(request) {
        const { resourceType, resource, id } = request;
        const vid = 1;
        let item = resource;
        item.resourceType = resourceType;
        item.meta = fhir_works_on_aws_interface_1.generateMeta(vid.toString());
        const params = dynamoDbParamBuilder_1.default.buildPutAvailableItemParam(item, id || v4_1.default(), vid);
        await this.dynamoDb.putItem(params).promise();
        const newItem = dynamoDb_1.DynamoDBConverter.unmarshall(params.Item);
        item = dynamoDbUtil_1.DynamoDbUtil.cleanItem(newItem);
        return {
            success: true,
            message: 'Resource created',
            resource: item,
        };
    }
    async deleteResource(request) {
        const { resourceType, id } = request;
        const itemServiceResponse = await this.readResource({ resourceType, id });
        const { versionId } = itemServiceResponse.resource.meta;
        return this.deleteVersionedResource(resourceType, id, parseInt(versionId, 10));
    }
    async deleteVersionedResource(resourceType, id, vid) {
        const updateStatusToDeletedParam = dynamoDbParamBuilder_1.default.buildUpdateDocumentStatusParam("AVAILABLE" /* AVAILABLE */, "DELETED" /* DELETED */, id, vid).Update;
        await this.dynamoDb.updateItem(updateStatusToDeletedParam).promise();
        return {
            success: true,
            message: `Successfully deleted ResourceType: ${resourceType}, Id: ${id}, VersionId: ${vid}`,
        };
    }
    async updateResource(request) {
        const { resource, resourceType, id } = request;
        const resourceCopy = { ...resource };
        const getResponse = await this.readResource({ resourceType, id });
        const currentVId = getResponse.resource.meta
            ? parseInt(getResponse.resource.meta.versionId, 10) || 0
            : 0;
        resourceCopy.meta = fhir_works_on_aws_interface_1.generateMeta((currentVId + 1).toString());
        const batchRequest = {
            operation: 'update',
            resourceType,
            id,
            resource: resourceCopy,
        };
        let item = {};
        // Sending the request to `atomicallyReadWriteResources` to take advantage of LOCKING management handled by
        // that method
        const response = await this.transactionService.transaction({
            requests: [batchRequest],
            startTime: new Date(),
        });
        item = fhir_works_on_aws_interface_1.clone(resource);
        const batchReadWriteEntryResponse = response.batchReadWriteResponses[0];
        item.meta = fhir_works_on_aws_interface_1.generateMeta(batchReadWriteEntryResponse.vid, new Date(batchReadWriteEntryResponse.lastModified));
        return {
            success: true,
            message: 'Resource updated',
            resource: item,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalCreateResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalUpdateResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    patchResource(request) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalPatchResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalDeleteResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
}
exports.DynamoDbDataService = DynamoDbDataService;
//# sourceMappingURL=dynamoDbDataService.js.map