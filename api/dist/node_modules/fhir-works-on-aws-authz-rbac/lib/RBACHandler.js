"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RBACHandler = void 0;
/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */
const jsonwebtoken_1 = require("jsonwebtoken");
// eslint-disable-next-line import/prefer-default-export
class RBACHandler {
    constructor(rules) {
        this.version = 1.0;
        this.rules = rules;
        if (this.rules.version !== this.version) {
            throw Error('Configuration version does not match handler version');
        }
    }
    async isAuthorized(request) {
        const decoded = jsonwebtoken_1.decode(request.accessToken, { json: true }) || {};
        const groups = decoded['cognito:groups'] || [];
        return this.isAllowed(groups, request.operation, request.resourceType);
    }
    async isBundleRequestAuthorized(request) {
        const decoded = jsonwebtoken_1.decode(request.accessToken, { json: true }) || {};
        const groups = decoded['cognito:groups'] || [];
        const authZPromises = request.requests.map(async (batch) => {
            return this.isAllowed(groups, batch.operation, batch.resourceType);
        });
        const authZResponses = await Promise.all(authZPromises);
        return authZResponses.every(Boolean);
    }
    async getAllowedResourceTypesForOperation(request) {
        const { accessToken, operation } = request;
        const decoded = jsonwebtoken_1.decode(accessToken, { json: true }) || {};
        const groups = decoded['cognito:groups'] || [];
        return groups.flatMap(group => {
            const groupRule = this.rules.groupRules[group];
            if (groupRule !== undefined && groupRule.operations.includes(operation)) {
                return groupRule.resources;
            }
            return [];
        });
    }
    isAllowed(groups, operation, resourceType) {
        if (operation === 'read' && resourceType === 'metadata') {
            return true; // capabilities statement
        }
        for (let index = 0; index < groups.length; index += 1) {
            const group = groups[index];
            if (this.rules.groupRules[group]) {
                const rule = this.rules.groupRules[group];
                if (rule.operations.includes(operation) &&
                    ((resourceType && rule.resources.includes(resourceType)) || !resourceType)) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.RBACHandler = RBACHandler;
//# sourceMappingURL=RBACHandler.js.map